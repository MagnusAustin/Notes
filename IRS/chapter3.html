<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Information Retrieval Concepts</title>
</head>
<body>
    <h1>1. Keywords Based Querying</h1>
    
    <h2>1.1 Keyword-Based Queries</h2>
    <ul>
        <li>Queries are the expression of user information needs, commonly using keywords.</li>
        <li>These queries are intuitive, simple, and allow for fast ranking.</li>
        <li>Queries can be single words or complex combinations of operations involving multiple words.</li>
        <li>Basic queries include both single-word and multiple-word queries, as well as patterns.</li>
    </ul>

    <h2>1.2 Single-Word Queries</h2>
    <ul>
        <li>The simplest form of query in a text retrieval system.</li>
        <li>Text documents are viewed as sequences of words.</li>
        <li>Some models also allow searching within the internal structure of words, enabling pattern searches.</li>
        <li>A word is defined by a sequence of letters separated by defined separators.</li>
        <li>Complex models may allow certain characters (e.g., hyphens) to be part of a word without splitting it.</li>
        <li>The text division into words is crucial for natural language meaning.</li>
        <li>Resulting documents are ranked based on the presence of query words and their similarity to the query.</li>
        <li>Ranking is commonly supported by statistics like term frequency and inverse document frequency.</li>
    </ul>

    <h2>1.3 Context Queries</h2>
    <ul>
        <li>Complement single-word queries by searching words within specific contexts.</li>
        <li>Context queries can involve phrases or proximity queries:
            <ul>
                <li><strong>Phrase Queries</strong>: Search for sequences of words as a phrase.</li>
                <li><strong>Proximity Queries</strong>: Search for words or phrases within a specified distance, with or without maintaining order.</li>
            </ul>
        </li>
        <li>Both phrase and proximity queries can be ranked, often without relying on physical proximity.</li>
    </ul>

    <h2>1.4 Boolean Queries</h2>
    <ul>
        <li>Use Boolean operators (AND, OR, BUT) to combine keyword queries.</li>
        <li>A query syntax tree is formed, where basic queries are the leaves, and operators are the internal nodes.</li>
        <li>Boolean queries operate on sets of documents, delivering a final set of documents as the answer.</li>
        <li>Classic Boolean systems do not rank documents; they either match the query or do not.</li>
        <li>Fuzzy Boolean operators relax the conditions for AND and OR, allowing partial matches and ranking documents based on the number of elements they share with the query.</li>
    </ul>

    <h2>1.5 Natural Language Queries</h2>
    <ul>
        <li>Extend the fuzzy Boolean model, blurring the distinction between AND and OR.</li>
        <li>Queries become an enumeration of words and contexts without explicit Boolean operations.</li>
        <li>Documents matching parts of the query are retrieved, with higher ranks for those matching more parts.</li>
        <li>Documents can be penalized or excluded based on the presence of unwanted words.</li>
        <li>The query is internally converted into a vector of term weights, and documents are retrieved based on their proximity to this vector.</li>
        <li>Allows advanced possibilities, such as using entire documents as queries or implementing relevance feedback techniques.</li>
    </ul>

    <h1>2. Pattern Matching</h1>

    <h2>2.1 Introduction to Pattern Matching</h2>
    <ul>
        <li>Pattern-based queries allow retrieval of text segments with specific properties.</li>
        <li>Useful for linguistics, text statistics, and data extraction.</li>
        <li>These queries can be integrated into basic queries like phrases and proximity queries.</li>
        <li>Ranking pattern matching results is challenging.</li>
    </ul>

    <h2>2.2 Pattern Definition</h2>
    <ul>
        <li>A pattern is a set of syntactic features required in a text segment.</li>
        <li>Segments matching these features are retrieved.</li>
        <li>Patterns range from simple (words) to complex (regular expressions).</li>
        <li>More powerful patterns allow more complex queries but also complicate implementation.</li>
    </ul>

    <h2>2.3 Types of Patterns</h2>
    <ul>
        <li><strong>Words</strong>: Basic pattern, a specific sequence of characters forming a word.</li>
        <li><strong>Prefixes</strong>: A string that forms the beginning of a word (e.g., "comput" matches "computer," "computation").</li>
        <li><strong>Suffixes</strong>: A string that forms the end of a word (e.g., "ters" matches "computers," "testers").</li>
        <li><strong>Substrings</strong>: A string appearing within a word or anywhere in the text (e.g., "tal" matches "coastal," "metallic").</li>
        <li><strong>Ranges</strong>: A pair of strings matching any word within their lexicographical order range (e.g., "held" to "hold" matches "hoax," "hissing").</li>
        <li><strong>Allowing Errors</strong>: Matches words similar to the query word within an allowed error threshold, often using Levenshtein distance (edit distance).</li>
    </ul>

    <h2>2.4 Regular Expressions</h2>
    <ul>
        <li><strong>Union</strong>: Matches any string that either of the expressions match.</li>
        <li><strong>Concatenation</strong>: Matches occurrences of one expression immediately followed by another.</li>
        <li><strong>Repetition</strong>: Matches zero or more occurrences of an expression (e.g., "pro (blem|tein) (s|e) (0|1|2)*" matches "problem02," "proteins").</li>
        <li>Matches can be restricted to whole words, within words, or arbitrary text segments.</li>
    </ul>

    <h2>2.5 Extended Patterns</h2>
    <ul>
        <li>User-friendly query languages simplify the syntax for regular expressions.</li>
        <li>These extended patterns are often system-specific and internally converted to regular expressions or searched with specific algorithms.</li>
    </ul>

    <h1>3. Structural Queries</h1>

    <h2>3.1 Introduction to Structural Queries</h2>
    <ul>
        <li>Utilizes text structure in queries, not just content.</li>
        <li>Combining structure and content in queries creates more expressive and powerful queries.</li>
        <li>Built on top of basic queries, adding constraints like containment, proximity, or structural elements (e.g., chapters, sections).</li>
        <li>Boolean queries can incorporate structural queries as components.</li>
    </ul>

    <h2>3.2 Types of Text Structures</h2>
    <ul>
        <li><strong>Fixed Structure</strong>:
            <ul>
                <li>Traditionally restrictive, resembling filled forms with fixed fields (e.g., mail archives).</li>
                <li>Fields contain text, often non-nestable or non-overlapping.</li>
                <li>Common in commercial systems, but inadequate for hierarchical structures like HTML.</li>
            </ul>
        </li>
        <li><strong>Hypertext</strong>:
            <ul>
                <li>Represents a directed graph where nodes contain text, and links connect nodes.</li>
                <li>Gained attention with the Web, which is a large hypertext-like database.</li>
                <li>Initially, retrieval was navigational, not structure-based.</li>
                <li>Tools like WebGlimpse combine browsing and content searching in hypertexts.</li>
            </ul>
        </li>
        <li><strong>Hierarchical Structure</strong>:
            <ul>
                <li>Lies between fixed structure and hypertext, representing recursive decomposition (e.g., books, legal documents).</li>
                <li>Simplified structure allows faster query algorithms.</li>
                <li>Less powerful than hypertext but more efficient.</li>
            </ul>
        </li>
    </ul>

    <h2>3.3 Hierarchical Models</h2>
    <ul>
        <li><strong>PAT Expressions</strong>:
            <ul>
                <li>Built on the text's index without a special structure index.</li>
                <li>Structure marked by tags in the text, allowing dynamic query-time determination.</li>
                <li>Efficient implementation with no additional space overhead.</li>
            </ul>
        </li>
        <li><strong>Overlapped Lists</strong>:
            <ul>
                <li>Allows region overlap but not nesting.</li>
                <li>Solves issues of mixing regions and position sets.</li>
                <li>Utilizes the lowest common ancestor for containment constraints.</li>
            </ul>
        </li>
        <li><strong>Grammatical Models</strong>:
            <ul>
                <li>Models text as a context-free grammar defining document structure.</li>
                <li>Represents each structure element as a context-free language.</li>
                <li>Text processing is constrained to legal structure expressions, improving system performance.</li>
            </ul>
        </li>
    </ul>
    <h1>4. Query Protocols</h1>

    <h2>1. Introduction to Query Protocols</h2>
    <ul>
        <li>Query protocols are used by software applications to query text databases automatically.</li>
        <li>They are often proposed as standards for querying CD-ROMs or library systems.</li>
        <li>Referred to as protocols because they are not designed for direct human use.</li>
    </ul>

    <h2>2. Key Query Protocols</h2>

    <h3>Z39.50</h3>
    <ul>
        <li>Approved as a standard in 1995 by ANSI and NISO.</li>
        <li>Queries bibliographical information using a standard interface between client and host database manager.</li>
        <li>Independent of client user interface and host query database language.</li>
        <li>Specifies query language, session establishment, communication, and information exchange between client and server.</li>
        <li>Originally for bibliographical information (MARC format), but extended for other types of information.</li>
    </ul>

    <h3>WAIS (Wide Area Information Service)</h3>
    <ul>
        <li>A suite of protocols popular in the early 1990s before the Web boom.</li>
        <li>Aimed to be a network publishing protocol and to query databases via the Internet.</li>
    </ul>

    <h2>3. CD-ROM Publishing Arena Query Protocols</h2>
    <ul>
        <li>Designed to provide ‘disk interchangeability,’ enabling flexible data communication and cost savings.</li>
    </ul>

    <h3>CCL (Common Command Language)</h3>
    <ul>
        <li>NISO proposal based on Z39.50, defines 19 interactive commands.</li>
        <li>More popular in Europe, though not widely adopted.</li>
        <li>Based on the classical Boolean model.</li>
    </ul>

    <h3>CD-RDx (Compact Disk Read Only Data exchange)</h3>
    <ul>
        <li>Uses client-server architecture, implemented on most platforms.</li>
        <li>The client is generic; the server is provided by the CD-ROM publisher.</li>
        <li>Supports fixed-length fields, images, and audio.</li>
        <li>Backed by US agencies like CIA, NASA, and GSA.</li>
    </ul>

    <h3>SFQL (Structured Full-text Query Language)</h3>
    <ul>
        <li>Based on SQL, with a client-server architecture.</li>
        <li>Adopted as a standard by the aerospace community.</li>
        <li>Documents are treated as rows in a relational table, and can be tagged using SGML.</li>
        <li>Supports Boolean/logical operators, thesaurus, proximity operations, and special characters.</li>
        <li>More general and flexible compared to CCL or CD-RDx, though based on a relational model, which may not always be ideal for document databases.</li>
    </ul>

    <h1>5. User Relevance Feedback</h1>

    <h2>1. Introduction to Relevance Feedback</h2>
    <ul>
        <li>Relevance feedback is a popular query reformulation strategy.</li>
        <li>The user reviews retrieved documents, marking relevant ones to refine the query.</li>
        <li>Typically, only the top 10 or 20 documents are examined.</li>
    </ul>

    <h2>2. Advantages of Relevance Feedback</h2>
    <ul>
        <li>Shields the user from the query reformulation process; user only provides relevance judgment.</li>
        <li>Breaks down the search task into smaller, manageable steps.</li>
        <li>Emphasizes relevant terms and de-emphasizes non-relevant ones.</li>
    </ul>

    <h2>3. Basic Procedure</h2>
    <ul>
        <li>User submits an initial query.</li>
        <li>System returns initial retrieval results.</li>
        <li>User marks documents as relevant or non-relevant.</li>
        <li>System refines the query based on feedback.</li>
        <li>System presents a revised set of results.</li>
        <li>The process may iterate multiple times to refine the query further.</li>
    </ul>

    <h2>4. Effectiveness of Relevance Feedback</h2>
    <ul>
        <li>Works well if the user’s initial query is somewhat close to the desired documents.</li>
        <li>Helps users refine their information needs through iterative search refinement.</li>
        <li>Improves precision significantly in the revised result set.</li>
    </ul>

    <h2>5. When Relevance Feedback May Not Work</h2>
    <ul>
        <li><strong>Misspellings</strong>: Spelling errors in the query may hinder effectiveness.</li>
        <li><strong>Cross-language retrieval</strong>: Documents in different languages do not cluster well in term distribution.</li>
        <li><strong>Vocabulary mismatch</strong>: Different terminologies (e.g., "laptop" vs. "notebook computer") can cause query failure.</li>
        <li><strong>Similarity of relevant documents</strong>: Relevant documents must cluster together in terms of term distribution.</li>
        <li><strong>Challenges with Multimodal Classes</strong>:
            <ul>
                <li>Subsets of documents using different vocabulary (e.g., "Burma" vs. "Myanmar").</li>
                <li>Disjunctive query answers (e.g., "Pop stars who once worked at Burger King").</li>
                <li>General concepts appearing as a disjunction of specific concepts (e.g., different types of felines).</li>
            </ul>
        </li>
    </ul>

    <h1>6. Multimedia IR</h1>

    <h2>1. Characteristics of Multimedia Systems</h2>
    <ul>
        <li>Supports a variety of data types, including text, images, graphs, and sound.</li>
        <li>More complex than traditional information systems due to heterogeneous data.</li>
        <li>Requires advanced data models, query languages, and storage mechanisms to manage complex data structures.</li>
    </ul>

    <h2>2. Need for Multimedia IR Systems</h2>
    <ul>
        <li>Traditional IR systems handle only textual, unstructured data.</li>
        <li>Multimedia IR systems are required to manage both structured and unstructured multimedia data.</li>
        <li>Multimedia IR systems use metadata and may employ a flexible schema to structure data.</li>
    </ul>

    <h2>3. Data Modeling in Multimedia IR</h2>
    <ul>
        <li>Multimedia IR systems must represent and store multimedia objects for fast retrieval.</li>
        <li>Handles semi-structured data and extracts features from multimedia objects for representation.</li>
        <li>Combines traditional and multimedia data types, extending the relational model for complex object representation.</li>
        <li>Uses multi-attribute access methods to index and search multimedia objects based on features.</li>
        <li>Features can be assigned to multimedia objects manually or automatically, often using a hybrid approach.</li>
        <li>Feature extraction is imprecise, so weights are assigned to features to represent uncertainty.</li>
    </ul>

    <h2>4. Data Retrieval in Multimedia IR</h2>
    <ul>
        <li><strong>Query Specification</strong>: Users specify queries with fuzzy, content-based, conventional, and structural predicates.</li>
        <li><strong>Query Processing and Optimization</strong>: Queries are parsed, compiled, and optimized, combining strategies for different data types.</li>
        <li><strong>Query Answer</strong>: Retrieved objects are returned in decreasing order of relevance, measured by a distance function from the query object.</li>
        <li><strong>Query Iteration</strong>: Users refine queries through iterations until satisfied, reducing or increasing the number of returned answers.</li>
    </ul>

    <h2>5. Challenges in Multimedia IR</h2>
    <ul>
        <li>Managing the heterogeneity and fuzziness of multimedia data.</li>
        <li>Loss of information during indexing.</li>
        <li>Need for interactive refinement of query results to handle imprecision in user requests.</li>
    </ul>
</body>
</html>
